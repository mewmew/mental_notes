<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset=UTF-8>

    <!-- Metadata -->

    <meta http-equiv="date" content="Thursday, 08  2015 14:00:00 GMT" />


    <meta name="keywords" content="gcc,ld" />


    <title>Better understanding Linux secondary dependencies solving with examples</title>

	<link rel="alternate" type="application/rss+xml" href="http://www.kaizou.org/feed/index.xml">
	<link rel="stylesheet" media="all" data-noprefix href="../../css/style.css">
	
  <script type="text/javascript" src="../../code/3rdparty/prefixfree/prefixfree.min.js"></script>
</head>
<body>
<div id='wrap'>
<header role="banner">
	<ul>
    	<li><a href='http://www.kaizou.org/'>Kaizou</a></li>
		<li><a href="http://www.kaizou.org/tools/">tools</a></li>
		<li><a href="http://www.kaizou.org/demos/">demos</a></li>
		<li><a href="http://www.kaizou.org/about.html">?</a></li>
	</ul>
</header>
<div id="content">
	<!-- Post -->
<div id='first-col'>
<article role='main'>
<header class='title'>
  <h1><a href="linux-libraries.html" rel="bookmark">Better understanding Linux secondary dependencies solving with examples</a></h1>
  <small><span>08 Jan 2015</span> by David Corvoysier</small>
</header>
<p>A few months ago I stumbled upon a linking problem with secondary dependencies I couldn’t solved without <a href="https://wiki.mageia.org/en/Overlinking_issues_in_packaging"><strong>overlinking</strong></a> the corresponding libraries.</p>

<p>I only realized today in a discussion with my friend <a href="http://ymorin.is-a-geek.org/">Yann E. Morin</a> that not only did I use the wrong solution for that particular problem, but that my understanding of the gcc linking process was not as good as I had imagined.</p>

<p>This blog post is to summarize what I have now understood.</p>

<p>There is also a <a href="https://github.com/kaizouman/linux-shlib-link-samples">small repository on github</a> with the mentioned samples.</p>

<!--more-->

<h1 id="a-few-words-about-linux-libraries">A few words about Linux libraries</h1>

<p>This paragraph is only a brief summary of what is very well described in <a href="http://tldp.org/HOWTO/Program-Library-HOWTO/introduction.html">The Linux Documentation Project library howto</a>.</p>

<p>Man pages for the linux <a href="http://linux.die.net/man/1/ld">linker</a> and <a href="http://linux.die.net/man/8/ld-linux">loader</a> are also a good source of information.</p>

<p>There are three kind of libraries in Linux: static, shared and dynamically loaded (DL).</p>

<p>Dynamically loaded libraries are very specific to some use cases like plugins, and would deserve an article on their own. I will only focus here on static and shared libraries.</p>

<h2 id="static-libraries">Static libraries</h2>

<p>A static library is simply an archive of object files conventionally starting with the <code class="highlighter-rouge">lib</code> prefix and ending with the <code class="highlighter-rouge">.a</code> suffix.</p>

<p><em>Example:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>libfoobar.a
</code></pre>
</div>

<p>Static libraries are created using the <strong>ar</strong> program:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ar rcs libfoobar.a foo.o bar.o
</code></pre>
</div>

<p>Linking a program with a static library is as simple as adding it to the link command either directly with its full path:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c /path/to/foobar/libfoobar.a
</code></pre>
</div>

<p>or indirectly using <a href="http://linux.die.net/man/1/ld">the <code class="highlighter-rouge">-l</code>/<code class="highlighter-rouge">L</code> options</a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -lfoobar -L/path/to/foobar
</code></pre>
</div>

<h2 id="shared-libraries">Shared libraries</h2>

<p>A shared library is an <strong>ELF</strong> object loaded by programs when they start.</p>

<p>Shared libraries follow the same naming conventions as static libraries, but with the <code class="highlighter-rouge">.so</code> suffix instead of <code class="highlighter-rouge">.a</code>.</p>

<p><em>Example:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>libfoobar.so
</code></pre>
</div>

<p>Shared library objects need to be compiled with the <code class="highlighter-rouge">-fPIC</code> option that produces position-independent code, ie code that can be relocated in memory.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -fPIC -c foo.c
$ gcc -fPIC -c bar.c
</code></pre>
</div>

<p>The <strong>gcc</strong> command to create a shared library is similar to the one used to create a program, with the addition of the <code class="highlighter-rouge">-shared</code> option.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -shared -o libfoobar.so foo.o bar.o
</code></pre>
</div>

<p>Linking against a shared library is achieved using the exact same commands as linking against a static library:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c libfoobar.so
</code></pre>
</div>

<p>or</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -lfoobar -L/path/to/foobar
</code></pre>
</div>

<h2 id="shared-libraries-and-undefined-symbols">Shared libraries and undefined symbols</h2>

<p>An <strong>ELF</strong> object maintains a table of all the symbols it uses, including symbols belonging to another <strong>ELF</strong> object that are marked as undefined.</p>

<p>At compilation time, the linker will try to <strong>resolve</strong> an undefined symbol by linking it either statically to code included in the overall output <strong>ELF</strong> object or dynamically to code provided by a shared library.</p>

<p>If an undefined symbol is found in a shared library, a <code class="highlighter-rouge">DT_NEEDED</code> entry is created for that library in the output <strong>ELF</strong> target.</p>

<p>The content of the <code class="highlighter-rouge">DT_NEEDED</code> field depends on the link command:</p>

<ul>
  <li>the full path to the library if the library was linked with an absolute path,</li>
  <li>the library name otherwise (or the library <a href="linux-libraries.html#library-versioning-and-compatibility"><strong>soname</strong></a> if it was defined).</li>
</ul>

<p>You can check the dependencies of an <strong>ELF</strong> object using the <strong>readelf</strong> command:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d main
</code></pre>
</div>

<p>or</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d libbar.so
</code></pre>
</div>

<p>When producing an executable a symbol that remains undefined after the link will raise an error: all dependencies must therefore be available to the linker in order to produce the output binary.</p>

<p>For historic reason, this behavior is disabled when building a shared library: you need to specify the <code class="highlighter-rouge">--no-undefined</code> (or <code class="highlighter-rouge">-z defs</code>) flag explicitly if you want errors to be raised when an undefined symbol is not resolved.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -Wl,--no-undefined -shared -o libbar.so -fPIC bar.c
</code></pre>
</div>

<p>or</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -Wl,-zdefs -shared -o libbar.so -fPIC bar.c
</code></pre>
</div>

<blockquote>
  <p>Note that when producing a static library, which is just an archive of object files, no actual ‘linking’ operation is performed, and undefined symbols are kept unchanged.</p>
</blockquote>

<h2 id="library-versioning-and-compatibility">Library versioning and compatibility</h2>

<p>Several versions of the same library can coexist in the system.</p>

<p>By conventions, two versions of the same library will use the same library name with a different version suffix that is composed of three numbers:</p>

<ul>
  <li>major revision,</li>
  <li>minor revision,</li>
  <li>build revision.</li>
</ul>

<p><em>Example:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>libfoobar.so.1.2.3
</code></pre>
</div>

<p>This is often referred as the library <strong>real name</strong>.</p>

<p>Also by convention, the library major version should be modified every time the library binary interface (<a href="http://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>) is modified.</p>

<p>Following that convention, an executable compiled with a shared library version is theoretically able to link with another version of the <strong>same major revision</strong>.</p>

<p>This concept if so fundamental for expressing compatibility between programs and shared libraries that each shared library can be associated a <strong>soname</strong>, which is the library name followed by a period and the major revision:</p>

<p><em>Example:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>libfoobar.so.1
</code></pre>
</div>

<p>The library <strong>soname</strong> is stored in the <code class="highlighter-rouge">DT_SONAME</code> field of the <strong>ELF</strong> shared object.</p>

<p>The <strong>soname</strong> has to be passed as a linker option to <strong>gcc</strong>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -shared -Wl,-soname,libfoobar.so.1 -o libfoobar.so foo.o bar.o
</code></pre>
</div>

<p>As mentioned before, whenever a library defines a <strong>soname</strong>, it is that <strong>soname</strong> that is stored in the <code class="highlighter-rouge">DT_NEEDED</code> field of <strong>ELF</strong> objects linked against that library.</p>

<h2 id="solving-versioned-libraries-dependencies-at-build-time">Solving versioned libraries dependencies at build time</h2>

<p>As mentioned before, libraries to be linked against can be specified using a shortened name and a path:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -lfoobar -L/path/to/foobar
</code></pre>
</div>

<p>When installing a library, the installer program will typically create a symbolic link from the library <strong>real name</strong> to its <strong>linker name</strong> to allow the linker to find the actual library file.</p>

<p><em>Example:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>/usr/lib/libfoobar.so -&gt; libfoobar.so.1.5.3
</code></pre>
</div>

<p>The linker uses the following search paths to locate required shared libraries:</p>

<ul>
  <li>directories specified by <code class="highlighter-rouge">-rpath-link</code> options (more on that later)</li>
  <li>directories specified by <code class="highlighter-rouge">-rpath</code> options (more on that later)</li>
  <li>directories specified by the environment variable <code class="highlighter-rouge">LD_RUN_PATH</code></li>
  <li>directories specified by the environment variable <code class="highlighter-rouge">LD_LIBRARY_PATH</code></li>
  <li>directories specified in <code class="highlighter-rouge">DT_RUNPATH</code> or <code class="highlighter-rouge">DT_RPATH</code> of a shared library are searched for shared libraries needed by it</li>
  <li>default directories, normally <code class="highlighter-rouge">/lib</code> and <code class="highlighter-rouge">/usr/lib</code></li>
  <li>directories listed inthe <code class="highlighter-rouge">/etc/ld.so.conf</code> file</li>
</ul>

<h2 id="solving-versioned-shared-libraries-dependencies-at-runtime">Solving versioned shared libraries dependencies at runtime</h2>

<p>On GNU glibc-based systems, including all Linux systems, starting up an <strong>ELF</strong> binary executable automatically causes the program loader to be loaded and run.</p>

<p>On Linux systems, this loader is named <a href="http://linux.die.net/man/8/ld-linux"><code class="highlighter-rouge">/lib/ld-linux.so.X</code></a> (where X is a version number). This loader, in turn, finds and loads recursively all other shared libraries listed in the <code class="highlighter-rouge">DT_NEEDED</code> fields of the <strong>ELF</strong> binary.</p>

<p>Please note that if a <strong>soname</strong> was specified for a library when the executable was compiled, the loader will look for the <strong>soname</strong> instead of the library real name. For that reason, installation tools automatically create symbolic names from the library <strong>soname</strong> to its <strong>real name</strong>.</p>

<p><em>Example:</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>/usr/lib/libfoobar.so.1 -&gt; libfoobar.so.1.5.3
</code></pre>
</div>

<p>When looking fo a specific library, if the value described in the <code class="highlighter-rouge">DT_NEEDED</code> doesn’t contain a <code class="highlighter-rouge">/</code>, the loader will consecutively look in:</p>

<ul>
  <li>directories specified at compilation time in the <strong>ELF</strong> object <code class="highlighter-rouge">DT_RPATH</code> (deprecated),</li>
  <li>directories specified using the environment variable <code class="highlighter-rouge">LD_LIBRARY_PATH</code>,</li>
  <li>directories specified at compile time in the <strong>ELF</strong> object <code class="highlighter-rouge">DT_RUNPATH</code>,</li>
  <li>from the cache file <code class="highlighter-rouge">/etc/ld.so.cache</code>, which contains a compiled list of candidate libraries previously found in the augmented library path (can be disabled at compilation time),</li>
  <li>in the default path <code class="highlighter-rouge">/lib</code>, and then <code class="highlighter-rouge">/usr/lib</code> (can be disabled at compilation time).</li>
</ul>

<h1 id="proper-handling-of-secondary-dependencies">Proper handling of secondary dependencies</h1>

<p>As mentioned in the introduction, my issue was related to secondary dependencies, ie shared libraries dependencies that are exported from one library to a target.</p>

<p>Let’s imagine for instance a program <strong>main</strong> that depends on a library <strong>libbar</strong> that itself depends on a shared library <strong>libfoo</strong>.</p>

<p>We will use either a static <strong>libbar.a</strong> or a shared <strong>libbar.so</strong>.</p>

<p><em>foo.c</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>int foo()
{
    return 42;
}
</code></pre>
</div>

<p><em>bar.c</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>int foo();

int bar()
{
    return foo();
}
</code></pre>
</div>

<p><em>main.c</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>int bar();

int main(int argc, char** argv)
{
    return bar();
}
</code></pre>
</div>

<h2 id="creating-the-libfooso-shared-library">Creating the libfoo.so shared library</h2>

<p><strong>libfoo</strong> has no dependencies but the <strong>libc</strong>, so we can create it with the simplest command:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -shared -o libfoo.so -fPIC foo.c
</code></pre>
</div>

<h2 id="creating-the-libbara-static-library">Creating the libbar.a static library</h2>

<p>As said before, static libraries are just archives of object files, without any means to declare external dependencies.</p>

<p>In our case, there is therefore no explicit connection whatsoever between libbar.a and libfoo.so.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -c bar.c
$ ar rcs libbar.a bar.o
</code></pre>
</div>

<h2 id="creating-the-libbarso-dynamic-library">Creating the libbar.so dynamic library</h2>

<p>The proper way to create the <strong>libbar.so</strong> shared library it by explicitly 
specifying it depends on <strong>libfoo</strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -shared -o libbar2.so -fPIC bar.c -lfoo -L$(pwd)
</code></pre>
</div>

<p>This will create the library with a proper <code class="highlighter-rouge">DT_NEEDED</code> entry for <strong>libfoo</strong>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d libbar.so
Dynamic section at offset 0xe08 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...
</code></pre>
</div>

<p>However, since undefined symbols are not by default resolved when building a shared library, we can also create a “dumb” version without any <code class="highlighter-rouge">DT_NEEDED</code> entry:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -shared -o libbar_dumb.so -fPIC bar.c
</code></pre>
</div>

<p>Note that it is very unlikely that someone actually chooses to create such an incomplete library on purpose, but it may happen that by misfortune you encounter one of these beasts in binary form and still <strong>need</strong> to link against it (yeah, sh… happens !).</p>

<h2 id="linking-against-the-libbara-static-library">Linking against the libbar.a static library</h2>

<p>As mentioned before, when linking an executable, the linker must resolve all undefined symbols before producing the output binary.</p>

<p>Trying to link only with <strong>libbar.a</strong> produces an error, since it has an undefined symbol and the linker has no clue where to find it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app_s main.c libbar.a
libbar.a(bar.o): In function `bar':
bar.c:(.text+0xa): undefined reference to `foo'
collect2: error: ld returned 1 exit status
</code></pre>
</div>

<p>Adding <strong>libfoo.so</strong> to the link command solves the problem:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c libbar.a -L$(pwd) -lfoo
</code></pre>
</div>

<p>You can verify that the <strong>app</strong> binary now explicitly depends on <strong>libfoo</strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d app
Dynamic section at offset 0xe18 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...
</code></pre>
</div>

<p>At run-time, the dynamic linker will look for <strong>libfoo.so</strong>, so unless you have installed it in standard directories (<code class="highlighter-rouge">/lib</code> or <code class="highlighter-rouge">/usr/lib</code>) you need to tell it where it is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LD_LIBRARY_PATH=$(pwd) ./app
</code></pre>
</div>

<p>To summarize, when linking an executable against a static library, you need to specify explicitly all dependencies towards shared libraries introduced by the static library on the link command.</p>

<blockquote>
  <p>Note however that expressing, discovering and adding implicit static libraries dependencies is typically a feature of your build system (<strong>autotools</strong>, <strong>cmake</strong>).</p>
</blockquote>

<h2 id="linking-against-the-libbarso-shared-library">Linking against the libbar.so shared library</h2>

<p>As specified in the <a href="http://linux.die.net/man/1/ld">linker documentation</a>, when the linker encounters an input shared library it processes all its <code class="highlighter-rouge">DT_NEEDED</code> entries as secondary dependencies:</p>

<ul>
  <li>if the linker output is a shared relocatable <strong>ELF</strong> object (ie a shared library), it will add all <code class="highlighter-rouge">DT_NEEDED</code> entries from the input library as new <code class="highlighter-rouge">DT_NEEDED</code> entries in the output,</li>
  <li>if the linker ouput is a non-shared, non-relocatable link (our case), it will automatically add the libraries listed in the <code class="highlighter-rouge">DT_NEEDED</code> of the input library on the link command line, producing an error if it can’t locate them.</li>
</ul>

<p>So, let’s see what happens when dealing with our two shared libraries.</p>

<h3 id="linking-against-the-dumb-library">Linking against the “dumb” library</h3>

<p>When trying to link an executable against the “dumb” version of <strong>libbar.so</strong>, the linker encounters undefined symbols in the library itself it cannot resolve since it lacks the <code class="highlighter-rouge">DT_NEEDED</code> entry related to <strong>libfoo</strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -L$(pwd) -lbar_dumb
libbar_dumb.so: undefined reference to `foo'
collect2: error: ld returned 1 exit status
</code></pre>
</div>

<p>Let’s see how we can solve this.</p>

<h4 id="adding-explicitly-the-libfooso-dependency">Adding explicitly the libfoo.so dependency</h4>

<p>Just like we did when we linked against the static version, we can just add <strong>libfoo</strong> to the link command to solve the problem:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -L$(pwd) -lbar_dumb -lfoo
</code></pre>
</div>

<p>It creates an explicit dependency in the <strong>app</strong> binary:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d app
Dynamic section at offset 0xe18 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libbar_dumb.so]
 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...
</code></pre>
</div>

<p>Again, at runtime you may need to tell the dynamic linker where <strong>libfoo.so</strong> is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ LD_LIBRARY_PATH=$(pwd) ./app
</code></pre>
</div>

<p>Note that having an explicit dependency to <strong>libfoo</strong> is not quite right, since our application doesn’t use directly any symbols from <strong>libfoo</strong>. What we’ve just done here is called <a href="https://wiki.mageia.org/en/Overlinking_issues_in_packaging"><strong>overlinking</strong></a>, and it is <strong>BAD</strong>.</p>

<p>Let’s imagine for instance that in the future we decide to provide a newer version of <strong>libbar</strong> that uses the same <strong>ABI</strong>, but based on a new version of <strong>libfoo</strong> with a different <strong>ABI</strong>: we should theoretically be able to use that new version of <strong>libbar</strong> without recompiling our application, but what would really happen here is that the dynamic linker would actually try to load the two versions of <strong>libfoo</strong> at the same time, leading to unpredictable results. We would therefore need to recompile our application even if it is still compatible with the newest <strong>libbar</strong>.</p>

<blockquote>
  <p>As a matter of fact, this <a href="https://lists.debian.org/debian-devel-announce/2005/11/msg00016.html">actually happened in the past</a>: a libfreetype update in the debian distro caused 583 packages to be recompiled, with only 178 of them actually using it.</p>
</blockquote>

<h4 id="ignoring-libfoo-dependency">Ignoring libfoo dependency</h4>

<p>There is another option you can use when dealing with the “dumb” library: tell the linker to ignore its undefined symbols altogether:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -L$(pwd) -lbar_dumb -Wl,--allow-shlib-undefined
</code></pre>
</div>

<p>This will produce a binary that doesn’t declare its hidden dependencies towards <strong>libfoo</strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d app
Dynamic section at offset 0xe18 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libbar_dumb.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...
</code></pre>
</div>

<p>This isn’t without consequences at runtime though, since the dynamic linker is now unable to resolve the executable dependencies:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./app: symbol lookup error: ./libbar_dumb.so: undefined symbol: foo
</code></pre>
</div>

<p>Your only option is then to load <strong>libfoo</strong> explicitly (yes, this is getting uglier and uglier):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ LD_PRELOAD=$(pwd)/libfoo.so LD_LIBRARY_PATH=$(pwd) ./app
</code></pre>
</div>

<h3 id="linking-against-the-correct-library">Linking against the “correct” library</h3>

<h4 id="doing-it-the-right-way">Doing it the right way</h4>

<p>As mentioned before, when linking against the correct shared library, the linker encounters the <strong>libfoo.so</strong> <code class="highlighter-rouge">DT_NEEDED</code> entry, adds it to the link command and finds it at the path specified by <code class="highlighter-rouge">-L</code>, thus solving the undefined symbols … or at least that is what I expected:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -L$(pwd) -lbar
/usr/bin/ld: warning: libfoo.so, needed by libbar.so, not found (try using -rpath or -rpath-link)
/home/diec7483/dev/linker-example/libbar.so: undefined reference to `foo'
collect2: error: ld returned 1 exit status
</code></pre>
</div>

<p>Why the error ? I thought I had done everything by the book !</p>

<p>Okay, let’s take a look at the <code class="highlighter-rouge">ld</code> man page again, looking at the <code class="highlighter-rouge">-rpath-link</code> option. This says:</p>

<blockquote>
  <p>When using ELF or SunOS, one shared library may require another. This happens when an “ld -shared” link includes a shared library as one of the input files.
When the linker encounters such a dependency when doing a non-shared, non-relocatable link, it will automatically try to locate the required shared library and include it in the link, if it is not included explicitly. In such a case, the -rpath-link option specifies the first set of directories to search. The -rpath-link option may specify a sequence of directory names either by specifying a list of names separated by colons, or by appearing multiple times.</p>
</blockquote>

<p>Ok, this is not crystal-clear, but what it actually means is that when specifying the path for a secondary dependency, you should not use <code class="highlighter-rouge">-L</code> but <code class="highlighter-rouge">-rpath-link</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gcc -o app main.c -L$(pwd) -lbar -Wl,-rpath-link=$(pwd)
</code></pre>
</div>

<p>You can now verify that <strong>app</strong> depends only on <strong>libbar</strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ readelf -d app
Dynamic section at offset 0xe18 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libbar.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...
</code></pre>
</div>

<p>And this is <strong>finally how things should be done</strong>.</p>

<blockquote>
  <p>You may also use <code class="highlighter-rouge">-rpath</code> instead of <code class="highlighter-rouge">-rpath-link</code> but in that case the specified path will be stored in the resulting executable, which is not suitable if you plan to relocate your binaries. Tools like <strong>cmake</strong> use the <code class="highlighter-rouge">-rpath</code> during the build phase (<code class="highlighter-rouge">make</code>), but remove the specified path from the executable during the installation phase(<code class="highlighter-rouge">make install</code>).</p>
</blockquote>

<h1 id="conclusion">Conclusion</h1>

<p>To summarize, when linking an executable against:</p>

<ul>
  <li>
    <p>a <strong>static</strong> library, you need to specify all dependencies towards other shared libraries this static library depends on explicitly on the link command.</p>
  </li>
  <li>
    <p>a <strong>shared</strong> library, you don’t need to specify dependencies towards other shared libraries this shared library depends on, but you may need to specify the path to these libraries on the link command using the <code class="highlighter-rouge">-rpath</code>/<code class="highlighter-rouge">-rpath-link</code> options.</p>
  </li>
</ul>

<blockquote>
  <p>Note however that expressing, discovering and adding implicit libraries dependencies is typically a feature of your build system (<strong>autotools</strong>, <strong>cmake</strong>), as demonstrated in my samples.</p>
</blockquote>

<!-- Comments -->
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'kaizouorg';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
</div>
<aside id='second-col'>
<div id="me">
<h2>Hi</h2>
<p>I am David Corvoysier, versatile developer and open Source enthusiast.</p>
</div>

<div id='social'>
  <h2>Follow me: 
    <a href="https://github.com/kaizouman">
<img alt="Kaizouman repository on github" src="../../images/Octocat.png" />
</a>
           
    <a href="http://www.kaizou.org/feed/">
<img alt="Site Feed" src="../../images/rss.svg" />
</a>

    <a href="https://twitter.com/kaizouda">
<img alt="Follow David Corvoysier in Twitter" src="../../images/twitter.png" />
</a>

    <a href="https://fr.linkedin.com/pub/david-corvoysier/a3/2aa/a90">
<img alt="David Corvoysier on linkedIn" src="../../images/linkedin.jpg" />
</a>

  </h2>
</div>

<!-- Related Posts -->
<div id="related-posts">
  <div class='tuple'><h2>Related Posts</h2></div>
    
        
        
            <div class='tuple'>
        
    	<article>
    <header>
      <h1><a href="http://www.kaizou.org/2016/09/boot-minimal-linux-qemu.html" rel="bookmark">Build and boot a minimal Linux system with qemu</a></h1>
      <small><span>23 Sep 2016</span> by David Corvoysier</small>
    </header>
    <section>
      <p>When you want to build a Linux system for an embedded target these days, it is very unlikely that you decide to do it from scratch.

Embedded Linux build systems are really smart and efficients, and will fit almost all use cases: should you need only a simple system, [buildroot](https://buildroot.org/) should be your first choice, and if you want to include more advanced features, or even create a full distribution, [Yocto](https://www.yoctoproject.org/) is the way to go.

That said, even if these tools will do all the heavy-lifting for you, they are not perfect, and if you are using less common configurations, you may stumble upon issues that were not expected. In that case, it may be important to understand what happens behind the scenes.

In this post, I will describe step-by-step how you can build a minimal Linux system for an embedded target and boot it using [QEMU](http://wiki.qemu.org/Main_Page).

</p>
      <p><a href="http://www.kaizou.org/2016/09/boot-minimal-linux-qemu.html">(more…)</a></p>
    </section>
    <footer>
      <span>Categories: 
        
        <a href="http://www.kaizou.org/categories.html#System" rel="tag">System</a>
        
      </span>
      <span>Tags: 
        
        <a href="http://www.kaizou.org/tags.html#build" rel="tag">build</a>
        
        <a href="http://www.kaizou.org/tags.html#linux" rel="tag">linux</a>
        
        <a href="http://www.kaizou.org/tags.html#croostool-ng" rel="tag">croostool-ng</a>
        
        <a href="http://www.kaizou.org/tags.html#qemu" rel="tag">qemu</a>
        
        <a href="http://www.kaizou.org/tags.html#busybox" rel="tag">busybox</a>
        
      </span>
    </footer>
</article>

        
    
        
        
    	<article>
    <header>
      <h1><a href="http://www.kaizou.org/2016/09/build-benchmark-large-c-project.html" rel="bookmark">Benchmarking build systems for a large C project</a></h1>
      <small><span>01 Sep 2016</span> by David Corvoysier</small>
    </header>
    <section>
      <p>The performance of build systems has been discussed at large in the developer community, with a strong emphasis made on the limitations of the legacy Make tool when dealing with large/complex projects.

I recently had to develop a build-system to create firmwares for embedded targets from more than 1000 source files.

The requirements were to use build recipes that could be customized for each directory and file in the source tree, similar to what the Linux Kernel does with [kbuild](https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt).

I designed a custom recursive Make solution inspired by [kbuild](https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt).

</p>
      <p><a href="http://www.kaizou.org/2016/09/build-benchmark-large-c-project.html">(more…)</a></p>
    </section>
    <footer>
      <span>Categories: 
        
        <a href="http://www.kaizou.org/categories.html#System" rel="tag">System</a>
        
      </span>
      <span>Tags: 
        
        <a href="http://www.kaizou.org/tags.html#build" rel="tag">build</a>
        
        <a href="http://www.kaizou.org/tags.html#make" rel="tag">make</a>
        
        <a href="http://www.kaizou.org/tags.html#ninja" rel="tag">ninja</a>
        
        <a href="http://www.kaizou.org/tags.html#kbuild" rel="tag">kbuild</a>
        
        <a href="http://www.kaizou.org/tags.html#cmake" rel="tag">cmake</a>
        
      </span>
    </footer>
</article>

        
            </div>
        
    
        
        
            <div class='tuple'>
        
    	<article>
    <header>
      <h1><a href="http://www.kaizou.org/2016/08/decentralized-modules-c-elf-sections.html" rel="bookmark">Decentralized modules declarations in C using ELF sections</a></h1>
      <small><span>17 Aug 2016</span> by David Corvoysier</small>
    </header>
    <section>
      <p>In modular programming, a standard practice is to define common interfaces allowing the same type of operation to be performed on a set of otherwise independent modules.

~~~~

modules = [a,b,...]

for each m in modules:
    m.foo
    m.bar

~~~~

To implement this pattern, two mechanisms are required:

- instantiation, to allow each module to define an 'instance' of the common interface,
- registration, to allow each module to 'provide' this instance to other modules.

Instantiation is typically supported natively in high-level languages.

Registration is more difficult and usually requires specific code to be written, or relying on external frameworks. 

Let's see how these two mechanisms can be implemented for C programs.

</p>
      <p><a href="http://www.kaizou.org/2016/08/decentralized-modules-c-elf-sections.html">(more…)</a></p>
    </section>
    <footer>
      <span>Categories: 
        
        <a href="http://www.kaizou.org/categories.html#System" rel="tag">System</a>
        
      </span>
      <span>Tags: 
        
        <a href="http://www.kaizou.org/tags.html#ELF" rel="tag">ELF</a>
        
        <a href="http://www.kaizou.org/tags.html#sections" rel="tag">sections</a>
        
      </span>
    </footer>
</article>

        
    
        
        
    	<article>
    <header>
      <h1><a href="http://www.kaizou.org/2014/11/gtest-cmake.html" rel="bookmark">Unit testing with GoogleTest and CMake</a></h1>
      <small><span>05 Nov 2014</span> by David Corvoysier</small>
    </header>
    <section>
      <p><p>Continuous integration requires a robust test environment to be able to detect regressions as early as possible.</p>

<p>A typical test environment will typically be composed of integration tests of the whole system and unit tests per components.</p>

<p>This post explains how to create unit tests for a <code class="highlighter-rouge">C++</code> component using <a href="https://github.com/google/googletest"><strong>GoogleTest</strong></a> and <a href="http://www.cmake.org/"><strong>CMake</strong></a>.</p>

</p>
      <p><a href="http://www.kaizou.org/2014/11/gtest-cmake.html">(more…)</a></p>
    </section>
    <footer>
      <span>Categories: 
        
        <a href="http://www.kaizou.org/categories.html#Linux" rel="tag">Linux</a>
        
      </span>
      <span>Tags: 
        
        <a href="http://www.kaizou.org/tags.html#CMake" rel="tag">CMake</a>
        
        <a href="http://www.kaizou.org/tags.html#GoogleTest" rel="tag">GoogleTest</a>
        
      </span>
    </footer>
</article>

        
            </div>
        
    
</div>
<div id='tag-cloud'>
  <div class='tuple'><h2>Tag cloud</h2></div>
    <a style='font-size: 70%' href='http://www.kaizou.org/tags.html#SVG'>SVG</a>
<a style='font-size: 124%' href='http://www.kaizou.org/tags.html#XHTML'>XHTML</a>
<a style='font-size: 111%' href='http://www.kaizou.org/tags.html#Cache'>Cache</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#HTTP'>HTTP</a>
<a style='font-size: 94%' href='http://www.kaizou.org/tags.html#HTML'>HTML</a>
<a style='font-size: 170%' href='http://www.kaizou.org/tags.html#HTML5'>HTML5</a>
<a style='font-size: 94%' href='http://www.kaizou.org/tags.html#Video'>Video</a>
<a style='font-size: 151%' href='http://www.kaizou.org/tags.html#CSS3'>CSS3</a>
<a style='font-size: 94%' href='http://www.kaizou.org/tags.html#Javascript'>Javascript</a>
<a style='font-size: 111%' href='http://www.kaizou.org/tags.html#Animation'>Animation</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#Benchmark'>Benchmark</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#Carousel'>Carousel</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#Canvas'>Canvas</a>
<a style='font-size: 124%' href='http://www.kaizou.org/tags.html#video'>video</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#cross-compilation'>cross-compilation</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#DBus'>DBus</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#CMake'>CMake</a>
<a style='font-size: 70%' href='http://www.kaizou.org/tags.html#build'>build</a>

</div>
</aside>

</div>
<footer role="contentinfo">
    <ul>
        <li>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
<img alt="Creative Commons License" src="../../../i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" />
</a>

        </li>
        <li>
            <span>Generated by <a href='http://github.com/mojombo/jekyll'>Jekyll</a></span>
        </li>
        <li>
            <a href="https://github.com/kaizouman">
<img alt="Kaizouman repository on github" src="../../images/Octocat.png" />
</a>
           
        </li>
        <li>
            <a href="http://www.kaizou.org/feed/">
<img alt="Site Feed" src="../../images/rss.svg" />
</a>

        </li>
        <li>
            <a href="https://twitter.com/kaizouda">
<img alt="Follow David Corvoysier in Twitter" src="../../images/twitter.png" />
</a>
            
        </li>
    </ul>
</footer>
</div>
<!-- Code Highlighting -->
<script type='text/javascript' src='../../js/code-highlight.js'>
</script>
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57955939-1', 'auto');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>

</body>
